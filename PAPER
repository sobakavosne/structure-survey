TITLE(1/2):     The impact of persistent data structures implementation on JavaScript
                performance

TITLE(2/2):     The impact of function implementation on the performance of a persistent 
                data structure processing

ABSTRACT:       The research is aimed to find quantitative (structure size) and qualitative  
                (implementation) correlations for persistent data structures on JavaScript 
                V8 execution via Node.js

SOURCE CODE:    [Source code](https://github.com/lenchevskii/structure-survey)

STRUCTURE LIB:  Mori vs. Lazy vs. Native vs. Immutable

FUNCTION LIB:   Ramda vs. Lodash vs. Underscore vs. Native vs. C++ Addon

MOTIVATION:     Find the real-world difference between functional implementations 

QUESTION:       Who's better uses JavaScript? 

MACHINE:        AMD Ryzen 9 5900HX | 4.680 GHz | 16 GB | SSD (1319.61 MB/sec)

BENCHMARK:      Absolute values → ops/sec over a call ⇒ higher is better

BENCHMARK LIB:  [Benchmark](https://github.com/bestiejs/benchmark.js)

ABBREVIATIONS:  N  - Native JavaScript
                I  - Immutable.js
                L  - Lazy.js
                M  - Mori.js
                R  - Ramda.js
                U  - Underscore.js
                D  - Lodash.js
                A  - C++ Addon

Part #1. Libraries overview

  To start our research we have to find out what do mean keywords from the STRUCTURE LIB 
  and FUNCTION LIB sections and briefly what is under the hood.

                STRUCTURE LIB

  Description:                                    Evaluation phases:

  • [Mori](http://swannodette.github.io/mori/) 
      Core is written in ClojureScript            ClojureScript -> 
                                                  JavaScript -> 
                                                  execution

  • [Lazy](https://danieltao.com/lazy.js/)
      Core is written in JavaScript               JavaScript -> 
                                                  execution

  • [Native](https://www.javascript.com/)
      JavaScript in-built structure               'direct' execution

  • [Immutable](https://immutable-js.com/)
      Core is written in TypeScript               TypeScript -> 
                                                  JavaScript -> 
                                                  execution

                FUNCTION LIB

  Description:                                    Evaluation phases:

  • [Ramda](https://ramdajs.com/)
      Core is written in JavaScript               JavaScript -> 
                                                  execution

  • [Lodash](https://lodash.com/)
      Core is written in JavaScript               JavaScript -> 
                                                  execution

  • [Underscore](http://underscorejs.org/)
      Core is written in JavaScript               JavaScript -> 
                                                  execution

  • [Native](https://www.javascript.com/)
      JavaScript in-built function interface      'direct' execution

  • [C++Addon](https://nodejs.org/api/n-api.html)
      Node.js in-built API                        C++ (compiled) -> 
                                                  Node API (ES "Agent") -> 
                                                  JavaScript call -> 
                                                  execution

Part #2. Components & conception

  The system is presented with a simple list of numbers generated by dint of tested
  libraries - STRUCTURE LIB. The mapping proceeds with functions from FUNCTION LIB. Each test 
  case is an iteration over a list with an identity function. The number of iterations is 
  ITER_MAX in the .env file. An identity function is chosen to find the speed of JavaScript
  interaction between libraries not to find JavaScript processing speed. There are 3 size 
  ranges presented: 100 - 1000, 1000 - 10000, 10000 - 100000. An iteration range is 1 - 10: 
  the number of iterations over a structure (0 means only structure generation). The rate given
  from Benchmark is measured in operations per second (op/sec) over a call: higher is better.
  Each case is visualized and presented as a plot.

Part #3. Data grid description

  Data structure colors:          Function implementation colors:
                                  
  • Mori      - Grey                 • Ramda       - Green
  • Lazy      - Purple               • Lodash      - Purple
  • Native    - Blue                 • Native      - Blue 
  • Immutable - Green                • Underscore  - Red
                                     • C++ Addon   - Grey

  Result form (3d-presented):     
                                  
  • X - Iteration, times
  • Y - Structure size, item
  • Z - Rate, op/sec

Part #4. Quality: The impact of implementation on performance of a structure processing

  #4.1 Case: Structure library - Functions. The impact of function implementation

    ...

  #4.2 Case: Function library - Structures. The impact of structure implementation

    ...

Part #5. Quantity: The impact of structure size on JS performance

  #5.1 Case: Structure library - Functions

    ...

  #5.2 Case: Function library - Structures

    ...

Part #6. Conclusions

...

> Regarding Part #7: The difference between pre-loaded structures and their direct calls is a time for 
foreign language processing.
